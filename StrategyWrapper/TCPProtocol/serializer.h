#ifndef CANSPEC_H
#define CANSPEC_H

#include <QtCore>
#include <QtEndian>
#include <QTcpSocket>
#include <QStringList>
#include <QFile>
#include <QDebug>
#include "tcpprotocol_global.h"
//TODO autogenerate this

#define TOTALIDs 2
#define DATAPERIOD 100 //in ms

enum Type {
    Float = 0,
    Other = 1,

    Int8 = 2,
    Int16 = 3,
    Int32 = 4,
    Int64 = 5,

    UInt8 = 6,
    UInt16 = 7,
    UInt32 = 8,
    UInt64 = 9,
    BitfieldBool = 10
};

struct LastDataStruct {
    LastDataStruct(Type type, bool toVis, bool toStrat, QString name) : type(type), toVis(toVis), toStrat(toStrat), dataSize(0), name(name) {}

    //make sure we don't copy the mutex
    LastDataStruct(const LastDataStruct& copy) :
        type(copy.type),
        dataFields(copy.dataFields),
        toVis(copy.toVis),
        toStrat(copy.toStrat),
        dataSize(copy.dataSize),
        name(copy.name) {}

    LastDataStruct& operator= (const LastDataStruct& data) {
        this->type = data.type;
        this->dataFields = data.dataFields;
        this->toVis = data.toVis;
        this->toStrat = data.toStrat;
        this->dataSize = data.dataSize;
        this->name = data.name;
        return *this;
    }
    Type type;
    QList<QByteArray> dataFields;
    QMutex mutex;
    bool toVis;
    bool toStrat;
    quint32 dataSize;
    QString name;
};

struct FieldSerializer {
public:
    virtual QByteArray fromLittle(QByteArray& data) = 0;
    virtual QByteArray toLittle(QByteArray& data) = 0;
    virtual const quint16 getSize() = 0;
};

struct NoChange : public FieldSerializer {
public:
    NoChange(quint16 size) : size(size) {}

    QByteArray fromLittle(QByteArray& data) override {
        return data;
    }
    QByteArray toLittle(QByteArray& data) override {
        return data;
    }
    const quint16 getSize() override {
        return size;
    }
private:
    const quint16 size;
};

template <typename T>
struct SerializeField : public FieldSerializer {
public:
    QByteArray fromLittle(QByteArray& data) override {
        QDataStream stream(&data, QIODevice::ReadWrite);
        T number;
        stream >> number;
        qFromLittleEndian(number);
        stream << number;
        return data;
    }

    QByteArray toLittle(QByteArray& data) override {
        QDataStream stream(&data, QIODevice::ReadWrite);
        T number;
        stream >> number;
        qToLittleEndian(number);
        stream << number;
        return data;
    }

    const quint16 getSize() override {
        return sizeof(T);
    }
};

class TCPPROTOCOLSHARED_EXPORT Serializer {
public:
    Serializer() : noChange1(1), noChange4(4),
                   serialize{&noChange4, &noChange1, &noChange1, &uInt16, &uInt32, &uInt64, &noChange1, &int16, &int32, &int64},
                   lookUp{ 50000 }, newDataSinceLastCall(false)
    {
        initializeIds(); //this is autogenerated
        showSpec();
    }

    QByteArray toLittleEndian(quint32 id, quint32 subId, QByteArray& data) {
        return toLittleEndian(dataStruct[id].second[subId].type, data);
    }

    QByteArray fromLittleEndian(quint32 id, quint32 subId, QByteArray& data) {
        return fromLittleEndian(dataStruct[id].second[subId].type, data);
    }

    QByteArray toLittleEndian(Type type, QByteArray& data) {
        return serialize[type]->toLittle(data);
    }

    QByteArray fromLittleEndian(Type type, QByteArray& data) {
        return serialize[type]->fromLittle(data);
    }
    QList<QPair<quint32, QList<LastDataStruct>>>* getData() {
        return &dataStruct;
    }

    void readAndChop(QTcpSocket* socket, quint32 id, quint32 dataSize, bool multipleLines) {
        if (lookUp[id] != 50000) { //skip if id doesn't point to a spot in the qlist
            QList<LastDataStruct>& fieldList = dataStruct[lookUp[id]].second;
            //read the first line
            for (int i = 0; i < fieldList.size() && dataSize > 0; i++) {
                fieldList[i].mutex.lock(); //close the mutex
                fieldList[i].dataFields.clear(); //clear the line

                quint16 thisSize = serialize[fieldList[i].type]->getSize();
                fieldList[i].dataFields.append(socket->read(thisSize)); //append datafield to list
                fieldList[i].dataSize = thisSize;
                dataSize -= thisSize;
            }
            if (!multipleLines) {
                if (dataSize > 0) { //canmessages are sometimes shorter than 8 bytes, so throw away the useless data
                    socket->read(dataSize);
                }
            }
            //if there are multiple lines in this datablock, read the rest of the lines, else throw away the rest of the size
            else {
                while (dataSize > 0 && dataSize > 0) {
                    for (int i = 0; i < fieldList.size() && dataSize > 0; i++) {
                        quint16 thisSize = serialize[fieldList[i].type]->getSize();
                        fieldList[i].dataFields.append(socket->read(thisSize)); //append datafield to list
                        fieldList[i].dataSize += thisSize;
                        dataSize -= thisSize;
                    }
                }
            }
            //open all mutexes again
            for (int i = 0; i < fieldList.size(); i++) {
                fieldList[i].mutex.unlock();
            }
            if (id >= 10) {
                newDataSinceLastCall = true;
            }
        }
    }

    QByteArray getLastData(quint32 id) {
        QList<LastDataStruct>& lastData = dataStruct[lookUp[id]].second;
        QByteArray data;
        for (int j = 0; lastData.last().dataFields.size(); j++) { //if there are multiple lines
            for (int i = 0; i < lastData.size(); i++) {
                lastData[i].mutex.lock();
                data.append(lastData[i].dataFields.at(j));
                lastData[i].mutex.unlock();
            }
        }
        return data;
    }

    /*QByteArray getLastData(quint32 id, quint32 subId) {
         QList<LastDataStruct>& lastData = dataStruct[lookUp[id]].second;
         QByteArray data;
         lastData[subId].mutex.lock();
         for (int j = 0; lastData[subId].dataFields.size(); j++) { //if there are multiple lines in this slot
            data.append(lastData[subId].dataFields.at(j));
         }
         lastData[subId].mutex.unlock();
         return data;
    }*/

    void sendStratCANData(QTcpSocket* socket) {
         for (int i = 0; i < dataStruct.size(); i++) {
            if (dataStruct[i].first >= 10) {
                for (int j = 0; j < dataStruct[i].second.size(); j++) {
                    LastDataStruct* str = &dataStruct[i].second[j];
                    if (str->toStrat && str->dataFields.length() > 0) {
                        str->mutex.lock();
                        socket->write(str->dataFields[0]);
                        str->mutex.unlock();
                    }
                }
            }
        }
    }

    QByteArray sendVisData() {
        QByteArray data;
         for (int i = 0; i < dataStruct.size(); i++) {
            if (dataStruct[i].first >= 10) {
                for (int j = 0; j < dataStruct[i].second.size(); j++) {
                    LastDataStruct* str = &dataStruct[i].second[j];
                    if (str->toVis && str->dataFields.length() > 0) {
                        str->mutex.lock();
                        data.append(str->dataFields[0]);
                        str->mutex.unlock();
                    }
                }
            }
        }
        return data;
    }

    //this has been created to sendfields without having to copy data. It should therefore be faster
    void sendField(quint32 id, QTcpSocket* socket, bool multipleLines) {
        //send the header
        union {
            quint32 value;
            char bytes[4];
        }idUnion, size;

        idUnion.value = id;
        idUnion.value = qToLittleEndian(idUnion.value);
        socket->write(idUnion.bytes); //write the id

        //if the data needs to be gathered in a non-trivial way, stop here and go to specialized functions
        if (id == 7) {
            return sendStratCANData(socket);
        }

        QList<LastDataStruct>& str = dataStruct[lookUp[id]].second;

        for (quint32 j = 0; j < str.size(); j++) {
            str[j].mutex.lock(); //lock all mutexes
        }
        if (multipleLines) {
            size.value = 0;
            for (quint32 j = 0; j < str.size(); j++) {
                size.value += str[j].dataSize;
            }
            size.value = qToLittleEndian(size.value);
            socket->write(size.bytes); //write the size
        }

        for (quint32 j = 0; j < str.size(); j++) { //send the first row
            socket->write(str[j].dataFields[0]);
        }

        if (multipleLines) { //send the rest of the rows
            for (quint32 i = 1; i < str[0].dataFields.size(); i++) { //loop over the rows
                for (quint32 j = 0; j < str.size(); j++) { //for each row, construct this row
                    socket->write(str[j].dataFields[i]);
                }
            }
        }
        for (quint32 j = 0; j < str.size(); j++) {
            str[j].mutex.unlock();
        }
    }

    bool checkNewData() {
        if (newDataSinceLastCall) {
            newDataSinceLastCall = false;
            return true;
        }
        return false;
    }

    QList<QPair<Type, QString>> getSpec(int beginId) {
        return getSpec(beginId, dataStruct.last().first); //return the spec until the last field
    }

    QList<QPair<Type, QString>> getSpec(int beginId, int endId) {
        QList<QPair<Type, QString>> spec;

        for (int i = lookUp[beginId]; i <= lookUp[endId]; i++) {
            for (int j = 0; j < dataStruct[i].second.length(); j++) {
                spec.append(qMakePair<Type, QString>(dataStruct[i].second[j].type,dataStruct[i].second[j].name));
            }
        }
        return spec;
    }



private:
    NoChange noChange1;
    NoChange noChange4;
    SerializeField<quint16> uInt16;
    SerializeField<quint32> uInt32;
    SerializeField<quint64> uInt64;
    SerializeField<qint16> int16;
    SerializeField<qint32> int32;
    SerializeField<qint64> int64;
    FieldSerializer* serialize[10];

    //fields
    //ID 32 field 2 would be at Qpair list position lookUp[32], and lastDataStruct list position 2.
    QList<QPair<quint32, QList<LastDataStruct>>> dataStruct;
    quint32 lookUp[2048];

    bool newDataSinceLastCall;

    void initializeIds(); //the autogenerated function
    int loadInCSVSpec(int i, QString file);
    void showSpec();
};


#endif // CANSPEC_H
